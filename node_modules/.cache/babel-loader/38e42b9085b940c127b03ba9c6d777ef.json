{"ast":null,"code":"var Duplex = require('stream').Duplex;\nvar Writable = require('stream').Writable;\nvar util = require('util');\nvar CopyStream = module.exports = function (pq, options) {\n  Duplex.call(this, options);\n  this.pq = pq;\n  this._reading = false;\n};\nutil.inherits(CopyStream, Duplex);\n\n// writer methods\nCopyStream.prototype._write = function (chunk, encoding, cb) {\n  var result = this.pq.putCopyData(chunk);\n\n  // sent successfully\n  if (result === 1) return cb();\n\n  // error\n  if (result === -1) return cb(new Error(this.pq.errorMessage()));\n\n  // command would block. wait for writable and call again.\n  var self = this;\n  this.pq.writable(function () {\n    self._write(chunk, encoding, cb);\n  });\n};\nCopyStream.prototype.end = function () {\n  var args = Array.prototype.slice.call(arguments, 0);\n  var self = this;\n  var callback = args.pop();\n  if (args.length) {\n    this.write(args[0]);\n  }\n  var result = this.pq.putCopyEnd();\n\n  // sent successfully\n  if (result === 1) {\n    // consume our results and then call 'end' on the\n    // \"parent\" writable class so we can emit 'finish' and\n    // all that jazz\n    return consumeResults(this.pq, function (err, res) {\n      Writable.prototype.end.call(self);\n\n      // handle possible passing of callback to end method\n      if (callback) {\n        callback(err);\n      }\n    });\n  }\n\n  // error\n  if (result === -1) {\n    var err = new Error(this.pq.errorMessage());\n    return this.emit('error', err);\n  }\n\n  // command would block. wait for writable and call end again\n  // don't pass any buffers to end on the second call because\n  // we already sent them to possible this.write the first time\n  // we called end\n  return this.pq.writable(function () {\n    return self.end.apply(self, callback);\n  });\n};\n\n// reader methods\nCopyStream.prototype._consumeBuffer = function (cb) {\n  var result = this.pq.getCopyData(true);\n  if (result instanceof Buffer) {\n    return setImmediate(function () {\n      cb(null, result);\n    });\n  }\n  if (result === -1) {\n    // end of stream\n    return cb(null, null);\n  }\n  if (result === 0) {\n    var self = this;\n    this.pq.once('readable', function () {\n      self.pq.stopReader();\n      self.pq.consumeInput();\n      self._consumeBuffer(cb);\n    });\n    return this.pq.startReader();\n  }\n  cb(new Error('Unrecognized read status: ' + result));\n};\nCopyStream.prototype._read = function (size) {\n  if (this._reading) return;\n  this._reading = true;\n  // console.log('read begin');\n  var self = this;\n  this._consumeBuffer(function (err, buffer) {\n    self._reading = false;\n    if (err) {\n      return self.emit('error', err);\n    }\n    if (buffer === false) {\n      // nothing to read for now, return\n      return;\n    }\n    self.push(buffer);\n  });\n};\nvar consumeResults = function consumeResults(pq, cb) {\n  var cleanup = function cleanup() {\n    pq.removeListener('readable', onReadable);\n    pq.stopReader();\n  };\n  var readError = function readError(message) {\n    cleanup();\n    return cb(new Error(message || pq.errorMessage()));\n  };\n  var onReadable = function onReadable() {\n    // read waiting data from the socket\n    // e.g. clear the pending 'select'\n    if (!pq.consumeInput()) {\n      return readError();\n    }\n\n    // check if there is still outstanding data\n    // if so, wait for it all to come in\n    if (pq.isBusy()) {\n      return;\n    }\n\n    // load our result object\n    pq.getResult();\n\n    // \"read until results return null\"\n    // or in our case ensure we only have one result\n    if (pq.getResult() && pq.resultStatus() !== 'PGRES_COPY_OUT') {\n      return readError('Only one result at a time is accepted');\n    }\n    if (pq.resultStatus() === 'PGRES_FATAL_ERROR') {\n      return readError();\n    }\n    cleanup();\n    return cb(null);\n  };\n  pq.on('readable', onReadable);\n  pq.startReader();\n};","map":null,"metadata":{},"sourceType":"script"}