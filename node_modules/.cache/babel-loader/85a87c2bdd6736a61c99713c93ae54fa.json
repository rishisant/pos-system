{"ast":null,"code":"var Libpq = require('libpq');\nvar EventEmitter = require('events').EventEmitter;\nvar util = require('util');\nvar assert = require('assert');\nvar types = require('pg-types');\nvar buildResult = require('./lib/build-result');\nvar CopyStream = require('./lib/copy-stream');\nvar Client = module.exports = function (config) {\n  var _this = this;\n  if (!(this instanceof Client)) {\n    return new Client(config);\n  }\n  config = config || {};\n  EventEmitter.call(this);\n  this.pq = new Libpq();\n  this._reading = false;\n  this._read = this._read.bind(this);\n\n  // allow custom type converstion to be passed in\n  this._types = config.types || types;\n\n  // allow config to specify returning results\n  // as an array of values instead of a hash\n  this.arrayMode = config.arrayMode || false;\n  this._resultCount = 0;\n  this._rows = undefined;\n  this._results = undefined;\n\n  // lazy start the reader if notifications are listened for\n  // this way if you only run sync queries you wont block\n  // the event loop artificially\n  this.on('newListener', function (event) {\n    if (event !== 'notification') return;\n    _this._startReading();\n  });\n  this.on('result', this._onResult.bind(this));\n  this.on('readyForQuery', this._onReadyForQuery.bind(this));\n};\nutil.inherits(Client, EventEmitter);\nClient.prototype.connect = function (params, cb) {\n  this.pq.connect(params, cb);\n};\nClient.prototype.connectSync = function (params) {\n  this.pq.connectSync(params);\n};\nClient.prototype.query = function (text, values, cb) {\n  var queryFn;\n  if (typeof values === 'function') {\n    cb = values;\n  }\n  if (Array.isArray(values) && values.length > 0) {\n    queryFn = function queryFn() {\n      return self.pq.sendQueryParams(text, values);\n    };\n  } else {\n    queryFn = function queryFn() {\n      return self.pq.sendQuery(text);\n    };\n  }\n  var self = this;\n  self._dispatchQuery(self.pq, queryFn, function (err) {\n    if (err) return cb(err);\n    self._awaitResult(cb);\n  });\n};\nClient.prototype.prepare = function (statementName, text, nParams, cb) {\n  var self = this;\n  var fn = function fn() {\n    return self.pq.sendPrepare(statementName, text, nParams);\n  };\n  self._dispatchQuery(self.pq, fn, function (err) {\n    if (err) return cb(err);\n    self._awaitResult(cb);\n  });\n};\nClient.prototype.execute = function (statementName, parameters, cb) {\n  var self = this;\n  var fn = function fn() {\n    return self.pq.sendQueryPrepared(statementName, parameters);\n  };\n  self._dispatchQuery(self.pq, fn, function (err, rows) {\n    if (err) return cb(err);\n    self._awaitResult(cb);\n  });\n};\nClient.prototype.getCopyStream = function () {\n  this.pq.setNonBlocking(true);\n  this._stopReading();\n  return new CopyStream(this.pq);\n};\n\n// cancel a currently executing query\nClient.prototype.cancel = function (cb) {\n  assert(cb, 'Callback is required');\n  // result is either true or a string containing an error\n  var result = this.pq.cancel();\n  return setImmediate(function () {\n    cb(result === true ? undefined : new Error(result));\n  });\n};\nClient.prototype.querySync = function (text, values) {\n  if (values) {\n    this.pq.execParams(text, values);\n  } else {\n    this.pq.exec(text);\n  }\n  throwIfError(this.pq);\n  var result = buildResult(this.pq, this._types, this.arrayMode);\n  return result.rows;\n};\nClient.prototype.prepareSync = function (statementName, text, nParams) {\n  this.pq.prepare(statementName, text, nParams);\n  throwIfError(this.pq);\n};\nClient.prototype.executeSync = function (statementName, parameters) {\n  this.pq.execPrepared(statementName, parameters);\n  throwIfError(this.pq);\n  return buildResult(this.pq, this._types, this.arrayMode).rows;\n};\nClient.prototype.escapeLiteral = function (value) {\n  return this.pq.escapeLiteral(value);\n};\nClient.prototype.escapeIdentifier = function (value) {\n  return this.pq.escapeIdentifier(value);\n};\n\n// export the version number so we can check it in node-postgres\nmodule.exports.version = require('./package.json').version;\nClient.prototype.end = function (cb) {\n  this._stopReading();\n  this.pq.finish();\n  if (cb) setImmediate(cb);\n};\nClient.prototype._readError = function (message) {\n  var err = new Error(message || this.pq.errorMessage());\n  this.emit('error', err);\n};\nClient.prototype._stopReading = function () {\n  if (!this._reading) return;\n  this._reading = false;\n  this.pq.stopReader();\n  this.pq.removeListener('readable', this._read);\n};\nClient.prototype._consumeQueryResults = function (pq) {\n  return buildResult(pq, this._types, this.arrayMode);\n};\nClient.prototype._emitResult = function (pq) {\n  var status = pq.resultStatus();\n  switch (status) {\n    case 'PGRES_FATAL_ERROR':\n      this._queryError = new Error(this.pq.resultErrorMessage());\n      break;\n    case 'PGRES_TUPLES_OK':\n    case 'PGRES_COMMAND_OK':\n    case 'PGRES_EMPTY_QUERY':\n      var result = this._consumeQueryResults(this.pq);\n      this.emit('result', result);\n      break;\n    case 'PGRES_COPY_OUT':\n    case 'PGRES_COPY_BOTH':\n      {\n        break;\n      }\n    default:\n      this._readError('unrecognized command status: ' + status);\n      break;\n  }\n  return status;\n};\n\n// called when libpq is readable\nClient.prototype._read = function () {\n  var pq = this.pq;\n  // read waiting data from the socket\n  // e.g. clear the pending 'select'\n  if (!pq.consumeInput()) {\n    // if consumeInput returns false\n    // than a read error has been encountered\n    return this._readError();\n  }\n\n  // check if there is still outstanding data\n  // if so, wait for it all to come in\n  if (pq.isBusy()) {\n    return;\n  }\n\n  // load our result object\n\n  while (pq.getResult()) {\n    var resultStatus = this._emitResult(this.pq);\n\n    // if the command initiated copy mode we need to break out of the read loop\n    // so a substream can begin to read copy data\n    if (resultStatus === 'PGRES_COPY_BOTH' || resultStatus === 'PGRES_COPY_OUT') {\n      break;\n    }\n\n    // if reading multiple results, sometimes the following results might cause\n    // a blocking read. in this scenario yield back off the reader until libpq is readable\n    if (pq.isBusy()) {\n      return;\n    }\n  }\n  this.emit('readyForQuery');\n  var notice = this.pq.notifies();\n  while (notice) {\n    this.emit('notification', notice);\n    notice = this.pq.notifies();\n  }\n};\n\n// ensures the client is reading and\n// everything is set up for async io\nClient.prototype._startReading = function () {\n  if (this._reading) return;\n  this._reading = true;\n  this.pq.on('readable', this._read);\n  this.pq.startReader();\n};\nvar throwIfError = function throwIfError(pq) {\n  var err = pq.resultErrorMessage() || pq.errorMessage();\n  if (err) {\n    throw new Error(err);\n  }\n};\nClient.prototype._awaitResult = function (cb) {\n  this._queryCallback = cb;\n  return this._startReading();\n};\n\n// wait for the writable socket to drain\nClient.prototype._waitForDrain = function (pq, cb) {\n  var res = pq.flush();\n  // res of 0 is success\n  if (res === 0) return cb();\n\n  // res of -1 is failure\n  if (res === -1) return cb(pq.errorMessage());\n\n  // otherwise outgoing message didn't flush to socket\n  // wait for it to flush and try again\n  var self = this;\n  // you cannot read & write on a socket at the same time\n  return pq.writable(function () {\n    self._waitForDrain(pq, cb);\n  });\n};\n\n// send an async query to libpq and wait for it to\n// finish writing query text to the socket\nClient.prototype._dispatchQuery = function (pq, fn, cb) {\n  this._stopReading();\n  var success = pq.setNonBlocking(true);\n  if (!success) return cb(new Error('Unable to set non-blocking to true'));\n  var sent = fn();\n  if (!sent) return cb(new Error(pq.errorMessage() || 'Something went wrong dispatching the query'));\n  this._waitForDrain(pq, cb);\n};\nClient.prototype._onResult = function (result) {\n  if (this._resultCount === 0) {\n    this._results = result;\n    this._rows = result.rows;\n  } else if (this._resultCount === 1) {\n    this._results = [this._results, result];\n    this._rows = [this._rows, result.rows];\n  } else {\n    this._results.push(result);\n    this._rows.push(result.rows);\n  }\n  this._resultCount++;\n};\nClient.prototype._onReadyForQuery = function () {\n  // remove instance callback\n  var cb = this._queryCallback;\n  this._queryCallback = undefined;\n\n  // remove instance query error\n  var err = this._queryError;\n  this._queryError = undefined;\n\n  // remove instance rows\n  var rows = this._rows;\n  this._rows = undefined;\n\n  // remove instance results\n  var results = this._results;\n  this._results = undefined;\n  this._resultCount = 0;\n  if (cb) {\n    cb(err, rows || [], results);\n  }\n};","map":null,"metadata":{},"sourceType":"script"}